This is Verilog code for a microprocessor that can perform addition/subtraction instructions, load/store instructions, logical instructions, branching instructions, and halt instructions 

![alt text](https://raw.githubusercontent.com/sidarthgiddu/HeartRateMonitor/master/microprocessor.PNG)

Program Counter (PC.v): If RESET = 1, then the PC loads 0 on the next rising clock edge. Normally, the PC increments by 2. This is because instructions are 16 bits wide, but the iRAM is only 8 bits wide so a single instruction is stored in 2 consecutive memory locations.

iRam: The PC reads an iRam instruction at the memory address that is held at the PC. The different iRam files contain different sequences of instructions for the microprocessor to run. 

Decoder (decoder.v): The decoder breaks up the instruction into various signals. There are 2 types of instructions: register-to-register and immediate format. First, I'll go over register to register format. OP specifies the type of instruction to be performed (e.g.LB, ANDI, ADD). For register-to-register instructions, OP is either 0000 (for NOP instructions), or 1111. RS is the address of a register file, and this address is output signal SA. RT is address of another register file, and this address is output signal SB. RD is address of a destination register, and this address is output signal DR. FUNCT is sent to the ALU, and it tells the ALU which operation to perform. For example, if FUNCT = 000, the ALU performs addition (*RS +*RT), and if FUNCT = 001 the ALU performs subtraction (*RS - *RT). MB is the ALU input mux select. For register to register instructions, MB always equals 0 since we not concerned with immediate values. MD is the output mux select. Data RAM instructions are handled by immediate format instructions, so MD always equals 0 for register-to-register instructions. LD is the register file write enable. LD is 1 for AND, ADD, OR, and SUB instructions and 0 for all other types of instructions. MW is the DRAM write enable. Data RAM instructions are handled by immediate format instructions, so MW always equals 0 for register-to-register instructions. The other type of instruction format is the immediate format. OP specifies the type of instruction to be performed. RS is the address of a register file, and this address is output signal SA. IMM is the immediate value added to the contents of the register file with memory address RS. IMM is output signal IMM in the decoder. RT is the address of a destination register file, and this address is output signal DR. MB is the ALU input mux select. For immediate instructions, MB always equals 1. MD is the output mux select. MD equals 0 for ALU operations and 1 for LOAD instructions. LD is the register file write enable. LD equals 1 for all immediate format instructions except STORE instructions. MW is the DRAM write enable. MW only equals 1 for store instructions because we are writing data into the DRAM.

Register (register.v): It has inputs CLK, RESET, [2:0] SA, [2:0] SB, [2:0] DR, [7:0] D_in, and LD. It has outputs [7:0] DataA and DataB. I also created a reg [7:0] r[7:0] that holds the contents of the register. DataA is assigned to the contents of the register at memory address SA, and DataB is assigned to the contents of the register at memory address SB. If RESET = 1, then at the next rising clock edge every value in the register is written to 0. If LD = 1, then D_in is written back into the destination register DR. For immediate instructions, the ALU has to select IMM instead of DataB. However, IMM is 6 bits, and it needs to be sign extended to 8 bits. The sign extended module (signextend.v) does this by duplicating the MSB twice.

ALU (alu.v): The ALU consists of an adder module (adder.v), a shifter module (shifter.v), a logical module (logical.v), and a control module (control.v). The ALU takes in *SA and either *SB or a sign-extended immediate value. The operation it performs on these two operands depends on the value of OP. The control module takes in OP and decodes it into signals BSEL, CISEL, OSEL, SHIFT_LA, SHIFT_LR, and LOGICAL_OP. These are all represented as wires in Verilog. BSEL and CISEL are used for addition and subtraction instructions. If ALU is performing addition, then BSEL and CISEL both equal 0. If ALU is performing subtraction, then BSEL and CISEL both equal 1. If SHIFT_LA is 1 then the instruction is a logical shift, otherwise arithmetic shift. If SHIFT_LR is 0, it is a shift left instruction, otherwise a shift right instruction. If LOGICAL_OP is 1, the operation is AND, otherwise OR. The ALU also outputs condition codes (C, V, N, Z) depending on the value of the output. If the carry-out bit is a 1, C = 1, 0 otherwise. If there is overflow, V = 1, 0 otherwise. If the output is less than 0, N = 1, 0 otherwise. If the output is 0, Z = 1, 0 otherwise. Condition codes dictate the next instruction fetched by the IRAM.

CPU (cpu.v): instantiated the PC, decoder, register, sign extend, and alu modules. I also created the ALU select mux and the output select mux in cpu.v. In the ALU, the B input is IMME if MB = 1, else the B input is DB. This is the ALU select mux; the code is “.B(MB ? IMME : DB).” In the register file, D_in is signal DC, which is equal to the output of the ALU is MD = 0. Else, DC equals the output of the data RAM. This is the output select mux; the code is “assign DC = MD ? Din : DD.”

Branching and halting logic: I added HALT support using an extra HALT signal from the decoder, set to 0 for every instruction except for the HALT instruction, where it was set to 1. Then, I included partial logic in the cpu module for the signal H, true if HALT and EN_L both are true, corresponding to the case in which the PC should be held at its former value. Otherwise, the PC incremented by 2 as normal. For branching functionality, I had to add three more output signals to our decoder, BS, OFF, and HALT. In the case of a branching instruction, I set OFF to the immediate value in the corresponding instruction bits, else set it to zero to ensure that no branching would occur. Then, in the cpu module, I created a wire to store the value of the sign extended offset {OFF[5], OFF, 0} to be added to the current incremented PC if branching occurred. Branching is based on the condition codes CVNZ for certain operations on the values in the registers. E.g., for the instruction BNE RT,RS,IMM, I performed the operation *RT- *RS in the ALU and set BS = 1 (~Z) to see if the condition *RT!=*RS was true and the branch should be taken. I performed similar operations for each of the other branch instructions, using correct BS inputs so that we could correctly check if the condition for branching was met.

